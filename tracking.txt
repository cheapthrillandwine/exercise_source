参照リンク
http://www.cellstat.net/tracking/3/
ここでは画像内で最も大きいものを識別する。OpenCvでは輪郭は点の集合として保持される。
輪郭を構成する点の重心を計算することによって近似的な図形の重心座標を求める。

findContours関数は2値画像の入力に使い、すべての輪郭、すべての白と黒の境界線を検出する。＝検出される輪郭が複数
→プログラム実行までわからないため可変長配列である必要がある。
さらに輪郭を構成する点の数もわからない。
→vectorライブラリを使用する。vectorは入れ子構造になる。

image, contours, hierarchy = cv2.findContours(入力画像, 抽出モード, 近似手法)
近似手法は統一してcv2.CHAIN_APPROX_SIMPLEを使用する。
黒ブロブは最外行列の頂点を反時計まわりに抽出する。
白ブロブは最外行列の外側を時計まわりに抽出する
黒が一番最初に検出される。
抽出モードは以下
RETR_EXTERNAL：もっとも外側の輪郭のみを抽出する。白ブロブの輪郭は検出しない。
RETR_LIST：白の輪郭、黒の輪郭、内側、外側関係なく同じ階層で輪郭が取得される。
RETR_CCOMP：まず黒ブロブの輪郭をすべて抽出した後に白ブロブの輪郭を抽出する。
RETR_TREE：入れ子構造になった輪郭を完全に表現する。黒ブロブを検出し、入れ子構造になっているブロブの外側→内側と順番に検出する。

パーティクルフィルタ（Particle filter）
確率分布による時系列データの予測手法。正確な位置を求めるのではなく、過去の時系列データから追跡対象が次は○○%の確率でこの辺に来るだろうという確率的な推定をする。
粒子フィルタや逐次モンテカルロ法とも呼ばれる。
順序
１．リサンプリング
→前フレームでの重みに従って、パーティクルをばら撒く（追跡対象の周りにパーティクル）
→初期状態の場合、前フレームがないので、追跡対象の周辺に一様にパーティクルを撒く
２．推定
→適当なモデルを使って現フレームにおける追跡対象の位置を推定し、パーティクルを少し動かす。
→動画のような2次元座標の場合、等速直線運動や適当な乱数のモデルが使われる
３．観測
→現フレームにおける各パーティクルの重み（正則化）を計算する。
→2の答え合わせをして実際の追跡対象の位置に近いパーティクルの重みを大きくする。
おもみが大きいパーティクルが集中している領域が追跡対象となる。